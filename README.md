Sample todolist application to practice Docker Compose

# Dependencies
* golang 1.16
* postgres 12.6
* make

SQL code is autogenerated with sqlc. Run `make dev-deps` if you do not have sqlc installed. 
Add queries to `db/queries` and run `make sqlc` to generate code for the queries.

# Endpoints
/todo - add an item to the list

## create an item
```
curl -X POST -H "Content-Type: application/json" -d '{"title": "Test todo 1"}' localhost:<HOST_PORT>/todo
```

## list all items
/list - list all the items
```
curl localhost:<HOST_PORT>/list
```

# Necessary Environment Variables
- DB_HOST
- DB_PORT
- DB_USER
- DB_PASS
- DB_NAME


# Practice

## Defining the application stack with Docker Compose.
1. Create a file `docker-compose.yaml` and define two services: `app` and `db`.
    * The `app` service must be built from `build/Dockerfile`. 
    * Use a pre-built `postgres:9.6-alpine` image for `db`

2. Configure the following environment variables for each service:
    * For `app`
    ```
      - DB_HOST=???
      - DB_PORT=???
      - DB_USER=todolist
      - DB_PASS=supersecret
      - DB_NAME=todolist
    ```
    * For `db`
    ```
      - POSTGRES_USER=todolist
      - POSTGRES_PASSWORD=supersecret
      - POSTGRES_DB=todolist
    ```
3. Configure the stack in such a way that `app` service starts only after `db` service is started successfully.
4. Configure the `app` service to restart `unless-stopped` and the db service to `always` restart.

The 9.6 alpine image requires a volume configuration to initialize correctly. At this point, since you have set the `db` service to always restart,  you can see the container is constantly restarting. 

## Volumes
### docker volumes
1. Define a docker volume named `db-data`
2. Make it available to the `db` service at: `/var/lib/postgres/data/9.6`
3. Run `docker-compose down --volumes` to destroy the stack.
4. Run `docker-compose up` to bring up the stack.
5. The database should come up now successfully. 

### bind mounts
1. Configure a new service called `test` from `busybox:1.33` image.
2. The `test` service should be started after the `app` service.
3. Configure environment variable `CREATE_URL` to point to the app's `todo` end point 
4. Configure a volume mount to mount the `test_create.sh` script to `/test/test_create.sh` on the container. 
5. Configure the service to run `/test/test_create.sh` on start.

## Service to Service Communication
1. Use `expose` to expose the service ports - 8080 for `app` and 5432 for `db`. Can `app` and `db` talk to each other? Can you `curl localhost:8080/healthz` ?
2. Use `ports` instead of `expose`.
3. Fill the correct environment variables `DB_HOST` and `DB_PORT` for `app` 
4. Use `docker-compose  port -- app` to find the HOST_PORT for the `app` service.
5. Submit a request to create a todoitem from your system.
```
curl -X POST -H "Content-Type: application/json" -d '{"title": "Test todo 1"}' localhost:<HOST_PORT>/todo
```
6. Create a new network called `new`
7. Only move the `db` service to the `new` network
    * Restart your stack.
    * Can `app` and `db` now talk to each other? Which network is `app` in and `db` in?
8. Configure an `alias` - `database` for the `db` service?
9. Configure `app` to join the `new` network.
10. Update `DB_HOST` to correct alias for the `db` service for `app`.
11. Create another network called `test`.
12. Configure both the `app` and `test` services to join the `test` network.
Which services can talk to each other and at what addresses?
 
## Finding logs
1. Run `docker-compose logs -f` to get logs for all the services in the stack. How can you tell which log line is from which service?
2. Run `docker-compose logs -f -- app` to get logs for only the `app` service.
3. Run `docker-compose top` to view the processes running in the stack.

## Scaling service.
1. Run `docker-compose up --scale app=2 ` to scale the `app` service to two instances.

## Profiles
1. Associate the `test` service with a `test` profile. 
2. Run `docker-compose up` to see which services come up.
3. Run `docker-compose --profile=test up` to see which services come up.

## Configuring your stack with Environment Variables
1. Instead of hardcoding the postgres version to 12.6, use an environment variable ${POSTGRES_VERSION} wherever necessary.
2. Create a `.env` file with the following content `POSTGRES_VERSION=9.6`
3. In a shell, run the following commands:
```
export POSTGRES_VERSION=12.6
docker-compose up 
```
What is the value of `$POSTGRES_VERSION`, what is the postgres version of the `db` service?
